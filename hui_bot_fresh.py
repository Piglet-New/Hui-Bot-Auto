# hui_bot_fresh.py
# Runtime: Python 3.12+
# deps: python-telegram-bot==20.3, pandas
import os, re, sqlite3, json
from datetime import datetime, timedelta, time as dtime
from typing import Tuple, Optional
import pandas as pd
from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes

# ====================== C·∫§U H√åNH ======================
TOKEN = os.getenv("TELEGRAM_TOKEN", "").strip()
if not TOKEN:
    raise SystemExit("Thi·∫øu TELEGRAM_TOKEN trong bi·∫øn m√¥i tr∆∞·ªùng.")
DB_FILE = "hui.db"
CONFIG_FILE = "config.json"
REPORT_HOUR = 8      # g·ª≠i b√°o c√°o th√°ng l√∫c 08:00 s√°ng
# ======================================================

# ----------------- DB -----------------
def db():
    conn = sqlite3.connect(DB_FILE)
    conn.execute("PRAGMA foreign_keys = ON")
    return conn

def init_db():
    c = db()
    c.execute("""
    CREATE TABLE IF NOT EXISTS lines(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        period_days INTEGER NOT NULL,
        start_date TEXT NOT NULL,
        legs INTEGER NOT NULL,
        face_value INTEGER NOT NULL,      -- m·ªánh gi√° d√¢y (M)
        floor_pct REAL NOT NULL,          -- gi√° s√†n %
        cap_pct REAL NOT NULL,            -- gi√° tr·∫ßn %
        dau_thao_pct REAL NOT NULL,       -- ƒë·∫ßu th·∫£o %
        status TEXT DEFAULT 'OPEN',
        created_at TEXT NOT NULL
    )""")
    c.execute("""
    CREATE TABLE IF NOT EXISTS auctions(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        line_id INTEGER NOT NULL,
        k INTEGER NOT NULL,
        bid_amount INTEGER NOT NULL,      -- s·ªë ti·ªÅn thƒÉm c·ªßa k·ª≥ k (VND)
        bid_date TEXT NOT NULL,
        UNIQUE(line_id, k),
        FOREIGN KEY(line_id) REFERENCES lines(id) ON DELETE CASCADE
    )""")
    c.execute("""
    CREATE TABLE IF NOT EXISTS reminders(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        line_id INTEGER NOT NULL,
        at_hhmm TEXT NOT NULL,
        FOREIGN KEY(line_id) REFERENCES lines(id) ON DELETE CASCADE
    )""")
    c.commit(); c.close()

# ----------------- UTIL -----------------
def load_cfg():
    if os.path.exists(CONFIG_FILE):
        try: return json.load(open(CONFIG_FILE, "r", encoding="utf-8"))
        except: return {}
    return {}

def save_cfg(cfg: dict):
    json.dump(cfg, open(CONFIG_FILE, "w", encoding="utf-8"))

def vn_money_to_int(s: str) -> int:
    """1tr=1_000_000; 5000k=5_000_000; 1k/1n=1_000; 100k/100n=100_000; h·ªó tr·ª£ s·ªë th∆∞·ªùng."""
    s = str(s).strip().lower().replace(".", "").replace(",", "")
    m = re.fullmatch(r"(\d+)\s*(tr|tri|trieu)", s)
    if m: return int(m.group(1)) * 1_000_000
    m = re.fullmatch(r"(\d+)\s*(k|ngan|ng√†n|n)", s)
    if m: return int(m.group(1)) * 1_000
    if s.endswith("k") or s.endswith("n"):  # fallback
        num = re.sub(r"(k|n)$","", s)
        return int(num) * 1_000
    return int(s)

def parse_date_ddmmyyyy(s: str) -> datetime:
    return datetime.strptime(s, "%d-%m-%Y")

def fmt_money(v: int|float) -> str:
    return f"{int(round(v)):,} ƒë".replace(",", ".")

def k_date(start_date: str, period_days: int, k: int) -> datetime:
    return parse_date_ddmmyyyy(start_date) + timedelta(days=(k-1)*period_days)

# --- T√çNH TO√ÅN ---
def payout_for_k(M:int, N:int, D:float, bid:int) -> int:
    """
    S·ªë ti·ªÅn ng∆∞·ªùi h·ªët k·ª≥ k nh·∫≠n:
    - L√Ω thuy·∫øt: (N-1)*(M - bid) - D*M
    """
    return int((N-1)*(M - bid) - D*M)

def roi_for_k(M:int, contrib_paid:int, received:int) -> float:
    base = contrib_paid if contrib_paid>0 else M
    return (received - contrib_paid) / base

# --------------- LOAD LINE ---------------
def load_line(line_id:int):
    conn = db()
    r = conn.execute("SELECT * FROM lines WHERE id=?", (line_id,)).fetchone()
    if not r: conn.close(); return None
    cols = ["id","name","period_days","start_date","legs","face_value","floor_pct",
            "cap_pct","dau_thao_pct","status","created_at"]
    line = dict(zip(cols, r))
    conn.close()
    return line

def current_k(line_id:int) -> int:
    """k hi·ªán t·∫°i = s·ªë b·∫£n ghi auctions + 1 (kh√¥ng v∆∞·ª£t qu√° N)."""
    conn = db()
    cnt = conn.execute("SELECT COUNT(*) FROM auctions WHERE line_id=?", (line_id,)).fetchone()[0]
    conn.close()
    return min(cnt+1, load_line(line_id)["legs"])

# ================== COMMANDS ==================
HELP_TEXT = (
"üëã **H·ª§I BOT ‚Äì phi√™n b·∫£n SQLite (kh√¥ng c·∫ßn Google Sheets)**\n\n"
"‚ú® **L·ªÜNH CH√çNH** (kh√¥ng d·∫•u, ng√†y **DD-MM-YYYY**):\n\n"
"1) **T·∫°o d√¢y**:\n"
"   `/tao <ten> <tuan|thang> <DD-MM-YYYY> <so_chan> <menh_gia> <gia_san_%> <gia_tran_%> <dau_thao_%>`\n"
"   V√≠ d·ª•: `/tao Hui10tr tuan 10-10-2025 12 10tr 8 20 50`\n"
"   üí° Ti·ªÅn c√≥ th·ªÉ vi·∫øt: 5tr, 250k, 1n, 1000k, 2.5tr‚Ä¶\n\n"
"2) **Nh·∫≠p thƒÉm theo k·ª≥**:\n"
"   `/tham <ma_day> <ky> <so_tien_tham> [DD-MM-YYYY]`\n"
"   V√≠ d·ª•: `/tham 1 1 2tr 10-10-2025`\n\n"
"3) **ƒê·∫∑t gi·ªù nh·∫Øc ri√™ng cho t·ª´ng d√¢y**:\n"
"   `/hen <ma_day> <HH:MM>`  V√≠ d·ª•: `/hen 1 07:45`\n\n"
"4) **Danh s√°ch / T√≥m t·∫Øt / G·ª£i √Ω h·ªët**:\n"
"   `/danhsach`\n"
"   `/tomtat <ma_day>`\n"
"   `/hoitot <ma_day> [roi|lai]`\n\n"
"5) **ƒê√≥ng d√¢y**: `/dong <ma_day>`\n\n"
"6) **B·∫≠t b√°o c√°o t·ª± ƒë·ªông h√†ng th√°ng (m√πng 1, 08:00)**:\n"
"   `/baocao [chat_id]`\n"
)

async def cmd_start(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    await upd.message.reply_text(HELP_TEXT, disable_web_page_preview=True)

async def cmd_baocao(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    cfg = load_cfg()
    if ctx.args:
        try: cid = int(ctx.args[0])
        except: return await upd.message.reply_text("‚ùå `chat_id` kh√¥ng h·ª£p l·ªá.")
    else:
        cid = upd.effective_chat.id
    cfg["report_chat_id"] = cid
    save_cfg(cfg)
    await upd.message.reply_text(f"‚úÖ ƒê√£ l∆∞u n∆°i nh·∫≠n b√°o c√°o t·ª± ƒë·ªông: `{cid}`.\n"
                                 f"Bot s·∫Ω g·ª≠i l√∫c **{REPORT_HOUR:02d}:00** ng√†y **01** h√†ng th√°ng.",
                                 parse_mode="Markdown")

async def cmd_tao(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    try:
        name = ctx.args[0]
        kind = ctx.args[1].lower()
        start = ctx.args[2]
        legs = int(ctx.args[3])
        face = vn_money_to_int(ctx.args[4])
        floor = float(ctx.args[5])
        cap = float(ctx.args[6])
        dau = float(ctx.args[7])

        period_days = 7 if kind in ("tuan","tu·∫ßn","week","weekly") else 30

        # validate % s√†n/tr·∫ßn
        if not (0 <= floor < cap <= 100):
            return await upd.message.reply_text("‚ùå `gia_san_%` ph·∫£i < `gia_tran_%` v√† trong [0..100].")

        conn = db()
        conn.execute("""
            INSERT INTO lines(name,period_days,start_date,legs,face_value,floor_pct,cap_pct,dau_thao_pct,status,created_at)
            VALUES(?,?,?,?,?,?,?,?, 'OPEN', ?)
        """, (name, period_days, start, legs, face, floor, cap, dau, datetime.now().isoformat()))
        conn.commit()
        line_id = conn.execute("SELECT last_insert_rowid()").fetchone()[0]
        conn.close()

        await upd.message.reply_text(
            "‚úÖ ƒê√£ t·∫°o d√¢y **#{}** ‚Äì **{}** ({})\n"
            "‚Ä¢ M·ªü: {}\n"
            "‚Ä¢ S·ªë ch√¢n: {}\n"
            "‚Ä¢ M·ªánh gi√°: {}\n"
            "‚Ä¢ S√†n: {}% ¬∑ Tr·∫ßn: {}% ¬∑ ƒê·∫ßu th·∫£o: {}%\n"
            .format(line_id, name, "H·ª•i tu·∫ßn" if period_days==7 else "H·ª•i th√°ng",
                    start, legs, fmt_money(face), floor, cap, dau),
            parse_mode="Markdown"
        )
    except Exception as e:
        await upd.message.reply_text(
            "‚ùå Sai c√∫ ph√°p.\n"
            "V√≠ d·ª•: `/tao Hui10tr tuan 10-10-2025 12 10tr 8 20 50`",
            parse_mode="Markdown"
        )

async def cmd_danhsach(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    conn = db()
    rows = conn.execute("SELECT id,name,period_days,start_date,legs,face_value,floor_pct,cap_pct,dau_thao_pct,status FROM lines ORDER BY id DESC").fetchall()
    conn.close()
    if not rows:
        return await upd.message.reply_text("üìÇ Ch∆∞a c√≥ d√¢y n√†o.")
    out = ["üìã **Danh s√°ch d√¢y**:"]
    for r in rows:
        kind = "Tu·∫ßn" if r[2]==7 else "Th√°ng"
        out.append(f"‚Ä¢ #{r[0]} ¬∑ {r[1]} ¬∑ {kind} ¬∑ m·ªü {r[3]} ¬∑ ch√¢n {r[4]} ¬∑ m·ªánh gi√° {r[5]:,} ƒë ¬∑ s√†n {r[6]}% ¬∑ tr·∫ßn {r[7]}% ¬∑ ƒë·∫ßu th·∫£o {r[8]}% ¬∑ {r[9]}")
    await upd.message.reply_text("\n".join(out), parse_mode="Markdown")

async def cmd_tham(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    try:
        line_id = int(ctx.args[0])
        k = int(ctx.args[1])
        bid = vn_money_to_int(ctx.args[2])
        dt = ctx.args[3] if len(ctx.args)>=4 else datetime.now().strftime("%d-%m-%Y")
    except:
        return await upd.message.reply_text("‚ùå C√∫ ph√°p: `/tham <ma_day> <ky> <so_tien_tham> [DD-MM-YYYY]`", parse_mode="Markdown")

    line = load_line(line_id)
    if not line: return await upd.message.reply_text("‚ùå Kh√¥ng t√¨m th·∫•y d√¢y.")
    if not (1 <= k <= line["legs"]):
        return await upd.message.reply_text(f"‚ùå K·ª≥ ph·∫£i trong [1..{line['legs']}].")

    # ki·ªÉm tra s√†n/tr·∫ßn
    floor_v = int(line["face_value"]*line["floor_pct"]/100.0)
    cap_v   = int(line["face_value"]*line["cap_pct"]/100.0)
    if bid < floor_v or bid > cap_v:
        return await upd.message.reply_text(
            f"‚ùå S·ªë thƒÉm {fmt_money(bid)} ngo√†i bi√™n.\n"
            f"‚Ä¢ S√†n: {fmt_money(floor_v)} ({line['floor_pct']}%)\n"
            f"‚Ä¢ Tr·∫ßn: {fmt_money(cap_v)} ({line['cap_pct']}%)")

    conn = db()
    try:
        conn.execute("INSERT INTO auctions(line_id,k,bid_amount,bid_date) VALUES(?,?,?,?)",
                     (line_id, k, bid, dt))
        conn.commit()
    except sqlite3.IntegrityError:
        conn.close()
        return await upd.message.reply_text("‚ö†Ô∏è K·ª≥ n√†y ƒë√£ c√≥ thƒÉm. D√πng s·ªë kh√°c ho·∫∑c /tomtat ƒë·ªÉ xem.")
    conn.close()

    # t√≠nh nhanh k·∫øt qu·∫£ k·ª≥ k
    M,N,D = line["face_value"], line["legs"], line["dau_thao_pct"]/100.0
    received = payout_for_k(M, N, D, bid)

    await upd.message.reply_text(
        "‚úÖ ƒê√£ ghi **thƒÉm k·ª≥ {}** cho d√¢y **#{}** ‚Äì {}\n"
        "‚Ä¢ ThƒÉm: {}\n‚Ä¢ Ng√†y: {}\n‚Ä¢ ∆Ø·ªõc ti·ªÅn nh·∫≠n h·ªët: **{}**"
        .format(k, line_id, line["name"], fmt_money(bid), dt, fmt_money(received)),
        parse_mode="Markdown"
    )

async def cmd_tomtat(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    try: line_id = int(ctx.args[0])
    except: return await upd.message.reply_text("‚ùå C√∫ ph√°p: `/tomtat <ma_day>`", parse_mode="Markdown")

    line = load_line(line_id)
    if not line: return await upd.message.reply_text("‚ùå Kh√¥ng t√¨m th·∫•y d√¢y.")
    conn = db()
    df = pd.read_sql_query("SELECT k, bid_amount, bid_date FROM auctions WHERE line_id=? ORDER BY k", conn, params=(line_id,))
    conn.close()

    M,N,D = line["face_value"], line["legs"], line["dau_thao_pct"]/100.0
    total_paid_before_k = 0
    rows = []
    for i in range(1, N+1):
        bid = int(df[df["k"]==i]["bid_amount"].iloc[0]) if (not df.empty and (df["k"]==i).any()) else None
        rec = payout_for_k(M,N,D,bid) if bid is not None else None
        if bid is not None:
            # tr∆∞·ªõc k·ª≥ i, m·ªói ch√¢n s·ªëng ƒë√£ g√≥p (i-1)*M
            contrib_paid = (i-1)*M
            roi = roi_for_k(M, contrib_paid, rec)
            rows.append(f"‚Ä¢ K·ª≥ {i}: thƒÉm {fmt_money(bid)} ‚Üí nh·∫≠n {fmt_money(rec)} ¬∑ ROI {roi*100:.2f}%")
        else:
            rows.append(f"‚Ä¢ K·ª≥ {i}: (ch∆∞a c√≥ thƒÉm) ‚Äî ng√†y d·ª± ki·∫øn {k_date(line['start_date'], line['period_days'], i).strftime('%d-%m-%Y')}")
    head = (
        f"üìå **D√¢y #{line['id']} ‚Äì {line['name']}** ({'Tu·∫ßn' if line['period_days']==7 else 'Th√°ng'})\n"
        f"‚Ä¢ M·ªü: {line['start_date']} ¬∑ Ch√¢n: {line['legs']} ¬∑ M·ªánh gi√°/k·ª≥: {fmt_money(M)}\n"
        f"‚Ä¢ S√†n: {line['floor_pct']}% ¬∑ Tr·∫ßn: {line['cap_pct']}% ¬∑ ƒê·∫ßu th·∫£o: {line['dau_thao_pct']}%\n"
    )
    await upd.message.reply_text(head + "\n".join(rows), parse_mode="Markdown")

async def cmd_hoitot(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if len(ctx.args)<1:
        return await upd.message.reply_text("‚ùå C√∫ ph√°p: `/hoitot <ma_day> [roi|lai]`", parse_mode="Markdown")
    line_id = int(ctx.args[0])
    metric = (ctx.args[1].lower() if len(ctx.args)>=2 else "roi")
    if metric not in ("roi","lai"): metric="roi"

    line = load_line(line_id)
    if not line: return await upd.message.reply_text("‚ùå Kh√¥ng t√¨m th·∫•y d√¢y.")
    conn = db()
    existing = pd.read_sql_query("SELECT k,bid_amount FROM auctions WHERE line_id=?", conn, params=(line_id,))
    conn.close()

    M,N,D = line["face_value"], line["legs"], line["dau_thao_pct"]/100.0
    best_k, best_val, best_roi = None, -1e18, None
    for i in range(1, N+1):
        # n·∫øu k·ª≥ ƒë√£ c√≥ thƒÉm => d√πng ƒë√∫ng s·ªë ƒë√≥; n·∫øu ch∆∞a c√≥, d√πng m·ª©c‚Ä¶ s√†n ƒë·ªÉ g·ª£i √Ω th·∫≠n tr·ªçng
        if not existing.empty and (existing["k"]==i).any():
            bid = int(existing[existing["k"]==i]["bid_amount"].iloc[0])
        else:
            bid = int(M*line["floor_pct"]/100.0)
        rec = payout_for_k(M,N,D,bid)
        contrib_paid = (i-1)*M
        roi = roi_for_k(M, contrib_paid, rec)
        key = (roi if metric=="roi" else (rec - contrib_paid))
        if key > best_val:
            best_val, best_k, best_roi = key, i, roi

    await upd.message.reply_text(
        "üîé **G·ª£i √Ω h·ªët theo {}** cho d√¢y **#{} ‚Äì {}**:\n"
        "‚Ä¢ N√™n h·ªët **k·ª≥ {}** (ng√†y {})\n"
        "‚Ä¢ ROI ∆∞·ªõc t√≠nh: **{:.2f}%**"
        .format("ROI%" if metric=="roi" else "l√£i tuy·ªát ƒë·ªëi",
                line_id, line["name"],
                best_k, k_date(line["start_date"], line["period_days"], best_k).strftime("%d-%m-%Y"),
                best_roi*100),
        parse_mode="Markdown"
    )

async def cmd_hen(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    try:
        line_id = int(ctx.args[0])
        hhmm = ctx.args[1]
        assert re.fullmatch(r"\d{2}:\d{2}", hhmm)
    except:
        return await upd.message.reply_text("‚ùå C√∫ ph√°p: `/hen <ma_day> <HH:MM>`", parse_mode="Markdown")
    conn = db()
    conn.execute("INSERT INTO reminders(line_id, at_hhmm) VALUES(?,?)", (line_id, hhmm))
    conn.commit(); conn.close()
    await upd.message.reply_text(f"‚è∞ ƒê√£ ƒë·∫∑t nh·∫Øc cho d√¢y #{line_id} l√∫c {hhmm} m·ªói {'tu·∫ßn' if load_line(line_id)['period_days']==7 else 'th√°ng'}. "
                                 f\"Tu·∫ßn n√†y b·∫°n ƒëo√°n thƒÉm bao nhi√™u? üòâ\"")

async def cmd_dong(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    try: line_id = int(ctx.args[0])
    except: return await upd.message.reply_text("‚ùå C√∫ ph√°p: `/dong <ma_day>`", parse_mode="Markdown")
    conn = db()
    conn.execute("UPDATE lines SET status='CLOSED' WHERE id=?", (line_id,))
    conn.commit(); conn.close()
    await upd.message.reply_text(f"üóÇÔ∏è ƒê√£ ƒë√≥ng & l∆∞u tr·ªØ d√¢y #{line_id}.")

# ================== JOBS ==================
async def monthly_report(ctx: ContextTypes.DEFAULT_TYPE):
    cfg = load_cfg(); chat_id = cfg.get("report_chat_id")
    if not chat_id: return
    today = datetime.now().date()
    if today.day != 1:  # g·ª≠i m√πng 1
        return
    conn = db()
    rows = conn.execute("SELECT id,name,period_days,start_date,legs,face_value,floor_pct,cap_pct,dau_thao_pct,status FROM lines").fetchall()
    conn.close()
    if not rows:
        return await ctx.bot.send_message(chat_id=chat_id, text="üìä B√°o c√°o th√°ng: ch∆∞a c√≥ d√¢y.")
    lines = []
    for r in rows:
        line = {"id": r[0],"name": r[1],"period_days": r[2],"start_date": r[3],"legs": r[4],
                "face_value": r[5],"floor_pct": r[6],"cap_pct": r[7],"dau_thao_pct": r[8],"status": r[9]}
        lines.append(f"#{line['id']} ¬∑ {line['name']} ¬∑ {'Tu·∫ßn' if line['period_days']==7 else 'Th√°ng'} ¬∑ m·ªánh gi√° {line['face_value']:,} ƒë ¬∑ ƒë·∫ßu th·∫£o {line['dau_thao_pct']}% ¬∑ tr·∫°ng th√°i {line['status']}")
    await ctx.bot.send_message(chat_id=chat_id, text="üìä **B√°o c√°o th√°ng**:\n" + "\n".join(lines), parse_mode="Markdown")

async def daily_reminders(ctx: ContextTypes.DEFAULT_TYPE):
    """M·ªói ph√∫t qu√©t l·ªãch nh·∫Øc theo HH:MM; g·ª≠i c√¢u d√≠ d·ªèm tu·ª≥ d√¢y tu·∫ßn/th√°ng."""
    now = datetime.now()
    hhmm = now.strftime("%H:%M")
    conn = db()
    rs = conn.execute("""
        SELECT r.line_id, r.at_hhmm, l.name, l.period_days
        FROM reminders r JOIN lines l ON l.id=r.line_id
        WHERE r.at_hhmm=?
    """, (hhmm,)).fetchall()
    conn.close()
    for line_id, hhmm, name, pdays in rs:
        style = "tu·∫ßn" if pdays==7 else "th√°ng"
        text = (f"‚è∞ Nh·∫Øc d√¢y #{line_id} ‚Äì {name} ({style})\n"
                f"H√¥m nay l√† gi·ªù nh·∫Øc {hhmm} ‚Äî b·∫°n ƒëo√°n **thƒÉm** bao nhi√™u ƒë√¢y? üòâ\n"
                f"G√µ: `/tham {line_id} <ky> <so_tien_tham>`",
                )
        await ctx.bot.send_message(chat_id=load_cfg().get("report_chat_id", None) or ctx.application.bot.id, text=text[0], parse_mode="Markdown")

def schedule_jobs(app):
    # b√°o c√°o th√°ng ‚Äì c·ª© 24h tick 1 l·∫ßn, h√†m t·ª± ki·ªÉm tra m√πng 1
    app.job_queue.run_repeating(monthly_report, interval=24*60*60, first=10)
    # nh·∫Øc gi·ªù theo ph√∫t
    app.job_queue.run_repeating(daily_reminders, interval=60, first=15)

# ================== MAIN ==================
def main():
    init_db()
    app = ApplicationBuilder().token(TOKEN).build()

    app.add_handler(CommandHandler("start", cmd_start))
    app.add_handler(CommandHandler("baocao", cmd_baocao))
    app.add_handler(CommandHandler("tao", cmd_tao))
    app.add_handler(CommandHandler("danhsach", cmd_danhsach))
    app.add_handler(CommandHandler("tham", cmd_tham))
    app.add_handler(CommandHandler("tomtat", cmd_tomtat))
    app.add_handler(CommandHandler("hoitot", cmd_hoitot))
    app.add_handler(CommandHandler("hen", cmd_hen))
    app.add_handler(CommandHandler("dong", cmd_dong))

    schedule_jobs(app)
    print("‚úÖ H·ª•i Bot ƒëang ch·∫°y‚Ä¶")
    app.run_polling()

if __name__ == "__main__":
    main()